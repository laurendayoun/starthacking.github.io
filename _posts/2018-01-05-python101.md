Hey there!

We’re going to crash course through the programming language **Python** to introduce you to the very basics of coding. If you have no or minimal coding background, then this is the place for you! Otherwise, feel free to move on and explore the rest of StartHacking.

# Table of Contents
1. Basics
2. Types
3. Expressions
4. Relationships/Booleans
5. Variables
6. Sequences
7. Strings
8. Lists
9. Tuples
10. Conditionals
11. If statements
12. Boolean operations
13. Looping
14. For statements
15. While statements
16. Functions
17. Classes

# Basics
In programming, there are 3 types of commands:
1. Executive
2. Conditional
3. Iterative


1. **Executive** means "do something". The classic way of thinking about a basic computer program is to think about a recipe. If you have a list of executive commands as your program to make a PB&J sandwich, your program would look like:

```
01 Take the bread.
02 Spread the jam.
03 Spread the butter.
```

All of these being direct commands. All of the above (01-03) are executive commands. In the context of robotics, an executive command can be "drive forward at some speed".

2. **Conditional statements** are of the form ``IF (something) THEN (do something) ELSE (do something else)`` . This allows the computer to make certain primitive decisions.

When the ``IF`` statement is constructed, usually the ``(something)`` has to to with the value of a variable. A variable is similar to variables in math class. They are letters (usually in programming, we use whole words), such as ``a``, ``b``, ``lengthOfRobot``, etc. They represent numbers, letters or words, and even true/false. For example:

```python
a = 3
b = "hello world"
lengthOfRobot = 3.1415
winningTheMatch = True
theSkyIsGreen = False
```

Variables do not have units; they are just numbers. There are different kinds of variables (integers, floats, doubles, characters, strings, booleans). The definitions of these are as follows:

**integer**, or **int** is a whole number without a decimal (e.g. 1,2, 5, 11, 100745).  
**float** or **double**. These are not the same thing, but basically they are detailed numbers, that can include decimals (3.14, 7.1342, 2234.31).  
**character** or **char** is just one letter such as "a" or "b" or "y".  
**string** is a set of characters, making up words, sentences, etc such as "hello world" or "this is fun" or "Try again".  
**boolean** is either ``True`` or ``False``; we use these to store the true value of certain statements.

3. **Iterative** means ``DO WHILE`` or ``FOR (this long) DO SOMETHING``. The difference between a conditional and an iterative is that a conditional statement "happens" or is evaluated once when ``(something)`` happens. But, an iterative can do some action repeatedly ``WHILE (something)`` is true or ``FOR`` a certain number of times.


# Sequences

## Strings
We’re going to get into more detail about strings. You can create strings in Python in different ways. For example:

```python
my_string  = 'Hello!'
my_other_string = "The quick brown fox jumped over the lazy dog."
very_long_string = '''Sometimes, you are going to have a giant
block of text that has multiple lines. In this case,
make sure to use three consecutive single or double
quotes.'''
pi = 3.14
pi_string = str(pi)

print(my_string)
print(my_other_string)
print(very_long_string)
```
Output:
```
<insert printed results here>
```

You might be wondering what pi and pi_string are. Pi is a float, but in order to treat it like a string and print it out, we have to transform it into a string. You can cast numbers into strings quite easily but you can’t turn a string into a number.

Strings are also immutable, which means that you can’t change the variable’s content after you assign it. If you want to change your string, you’ll have to create a new string variable or directly reassign the string variable.

You can add two strings together using the ‘+’ operator, much like math. This is known as concatenation, which means the action of linking things together. For example:

```python
a = "Hello "
b = "world!"
c = a + b
print(c)
```
Output:
```
<insert printed results here>
```

You can also **slice** strings to obtain sections or even individual letters from the string. It can be done in this way:

```python
my_string = "dank memes"
print(my_string[0:3])
```
Output:
```
<insert printed results here>
```

Python reads this as ``[start:finish]`` where the ``start`` is the first character we want and ``finish`` is the first character we don't want. Python, similar to other programming languages, is **zero-indexed**, which means that the position of the first element is position 0. A little confusing? Here’s a diagram to help:

index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
-------|---|---|---|---|---|---|---|---|---|---|
string | d | a | n | k |   | m | e | m | e | s |

You can also use negative values when slicing in order to access the end of the string.

```python
my_string = "dank memes"
print(my_string[0:-6])
```
Output:
```
<insert printed results here>
```

Here are some other ways to use slicing.

```python
my_string = "dank memes"
print(my_string[:])
print(my_string[7])
print(my_string[:1])
```
Output:
```
<insert printed results here>
```

## Lists
Next, we’re going to be checking out another data type: lists. Lists are actually quite similar to strings, so what you’ve learned above will also apply here. Instead of being a collection of characters, lists are a collection of pretty much any other kind of object that exists in Python, such as integers and booleans. However, lists are mutable, which means that you will be able change the data without recreating the list.

You can create empty lists in Python as follows:
```python
my_list = []
my_list = list()
```

You can create filled lists as follows:
```python
my_list = [3, 2, 1]
colors = ["red", "blue", "green"]
random = ["pie", 3.14, "tau", 5.28]
```

You can even create a list of lists!
```
list_of_lists = [my_list, colors]
print(lists_of_lists)
```
Output:
```
<insert printed results here>
```

You can combine lists as well, using concatenation.
```python
combined_lists = my_list + colors
print(combined_lists)
```
Output:
```
<insert printed results here>
```

And, you can also slice lists, just like strings.
```python
my_list = [1, 2, 3, 4, 5]
print(my_list[0])
print(my_list[1:3])
```
Output:
```
<insert printed results here>
```

If you would like to reassign certain objects in the list, you can do so by calling it’s index and reassigning. It’s pretty simple!

```
my_list = [1, 2, 3, 4, 5]
my_list[0] = 0
print(my_list)
```
Object:
```
<insert printed results here>
```

There are other sequences in Python, such as tuples and dictionaries. Feel free to explore them on your own! You’ll find them both similar and different to what we have discussed here--which is what makes coding versatile. Their unique qualities allows each type of sequence to be utilized in various ways.

# Conditionals

## ``if`` / ``elif`` / ``else``

While programming, you will want to check if something is true or not. Let’s say that you’re in the kitchen. You might have a train of thought like this:

```
Am I hungry?
If yes: make a sandwich.
Otherwise: leave the kitchen.
```

The coding for this is also pretty straightforward. Let’s look at some examples to get you used to ``if`` statements!

```python
if 100 > 10:
print("true")
else:
print("false")
```
Output:
```
<insert printed results here>
```

```python
if 100 < 10:
print("false")
else:
print("true")
```
Output:
```
<insert printed results here>
```

```python
a = 100
b = 10
if a < b:
print(b)
elif a > b:
print(a)
```
Output:
```
<insert printed results here>
```

If the ``if``/``elif`` statement is satisfied (i.e. it is true), then it will run whatever is indented below it. Indentation is essential in Python. Any indented code will only run if the code that it is under is true. You can think of code as a giant file cabinet, where each line of code is a folder, and indented lines are files inside the folder. You can only access the "indented" files if the folder it is in allows you to.
You’ve seen if statements and you’ve seen ``elif`` statements. What exactly are ``elif`` statements? You can think of ``elif`` as short for "else if". The program only checks these statements if whatever above them is false. They must be used after an if statement, but you can also have a long line of elif statements if that is what you need. Else statements are optional, but it is good practice to use them as defaults. Whatever is indented under an else statement will only run only if every other ``if`` and ``elif`` statement above it renders as false.

# Boolean Operators

You are going to want to do a lot more than just using ``<`` and ``>`` in ``if`` statements. This is where Boolean operations come in.

Operator | Meaning
---------|---------
or  | at least one statement has to be true in order for the total to be True
and |  both statements must be true in order  for the total to be True
not | flips the statement so that whatever is False is True, and vice versa

Let’s take a look at Boolean operations in action!
```python
a = 1
b = 7

if a > 5 or b > 5:
  print("true")
else:
  print("false")
```
Output:
```
<insert printed results here>
```

This prints ``True`` because while a is not greater than 5, b is greater than 5. Only one of the statements has to be true when or is used.

```python
if a > 5 and b > 5:
  print("true")
else:
  print("false")
```
Output:
```
<insert printed results here>
```

This prints ``False`` because a > 5 is false. Both have to be true for the statement to be true!

```python
x = True
y = False

if x and not y:
  print("true")
else:
  print("false")
```
Output:
```
<insert printed results here>
```

Why does it print "true"? Let’s take a look at it. The ``x`` evaluates as ``True``, and ``y`` evaluates as ``not False``, which is ``True``! Both are ``True``, therefore the if statement evaluates as ``True``.

You can mix and match all the Boolean conditionals to fit your needs while programming!


# Looping

##``for`` loops

For loops are useful when you have blocks of code that you’d like to repeat a certain number of times. Let’s say you’re back in the kitchen, making sandwiches - but this time you’re packing several for a lunch with 5 friends. You’re going over the same motions ("iterating") for a fixed number of repeats. What would this look like in Python?

```python
for x in range(1,6):
  print("Packing sandwich #" + str(x))
```
Output:
```
<printed results>
```

There’s a couple things to unpack here. On the first line, we begin our for loop. We’re looping over every x in the range from 1 to 5. Why 5, you might ask, since it looks like we’re going from 1 to 6? This is because of the parameters that the range function takes: range([start], stop[, step]). Whenever you use range, you need to give it a stop value, and range will generate numbers up to, but not including, that value. You can optionally pass it any start value, and that is inclusive. Otherwise, range will start with 0. Step specifies the difference between each number in the sequence, so you could use a step of 2 to have range generate just even numbers, for example.

On the second line, we have the actual body of our for loop. This is the code that the loop will repeat for each value of x. In this simple example, it’s just a print statement. But note the indent: this is what tells Python to repeat this particular block. This is also a nice reminder of casting and string concatenation!

We don’t just have to use range in for loops - we can iterate over strings and lists, for example. Here’s an example where we print each letter in the word "sandwich" on a different line:

```python
word = "sandwich"
for letter in word:
  print(letter)
```
Output:
```
<printed results>
```

Our for loop considers each character in "sandwich" (contained in the variable word), and prints it. Here’s another example, but this time with a list:

```python
friends = ["Alice", "Bob", "Charlie", "Dave", "Eve"]
for friend in friends:
  print("Hi, " + friend + "! Have a sandwich.")
```
Output:
```
<printed results>
```

This loop considers each element of the list of friends, and offers them a sandwich.

These examples so far have been pretty basic, but we can make our for loops much more complicated. Let’s add conditionals! Say you have a list of possible sandwich fillings, but you want to print out just the ones that have bacon. How would you go about doing that?

```python
fillings = [["ham","cheese"], ["chicken","avocado","bacon"], ["egg","mayo"],["bacon","lettuce", "tomato"], ["cheese","turkey"]]
for x in fillings:
  if "bacon" in x:
    print(x)
```
Output:
```
<results>
```

Note that here, we’re iterating over a list of lists. This just means that each time the for loop runs its code block, it’s considering another list. The block just checks if "bacon" is in the list of ingredients for that particular filling, and prints the ingredients if it is.

Now let’s look at a different kind of loop, called a ``while`` loop.

## ``while`` loops
While loops are also used for repeating blocks of code, but not for a fixed number of repetitions. The block will be run until some condition is met. Let’s consider a basic while loop:

```python
i = 1
while i < 5:
  print(i)
  i += 1
```
Output:
```
<results>
```

Let’s break this down line by line. On the first line, we’ve created a counter variable i and set it to 1. The second line is the beginning of our loop: we’re going to keep running it until the condition ``i < 5`` is met. The next two indented lines are the block that will repeat. The first indented line is just a print statement, but the second one is more interesting: we’re incrementing the counter i by 1. i += 1 is just a more compact way of writing i = i+1, and it makes sure that we don’t endlessly get stuck in the loop: if we never increased i, the condition i<5 would always be true and we’d have an infinite loop which would never end. This is not something you usually want in your code. What about the condition? What if we changed it to i <= 5? We’d print the numbers from 1 to 5 this time, instead of 1 to 4.

There are a bunch of numerical examples we could go over, but while loops get more interesting when we include user input. Let’s go over the code for a simple number guessing game:

```python
guess = 0
while guess != to_be_guessed:
  guess = int(input("New number: "))
  if guess > 0:
    if guess > to_be_guessed:
      print("Number too large")
    elif guess < to_be_guessed:
      print("Number too small")
  else:
    print("Sorry that you're giving up!")
    break

if guess == to_be_guessed:
  print("Congratulations. You made it!")
```

Let’s assume that to_be_guessed has been set to some random number outside of this block of code. The first line initializes a guess variable, and from there on it’s the while loop. The loop runs as long as the guess is incorrect. Inside the loop, the first thing we do is get a guess from the user - the input function takes a string using the prompt in quotes ("New number: "). The first if/else block checks to see if the guess is valid. We’ll talk later about other, more comprehensive ways this can be done. Inside the first if block we have another if/else block to tell the user how they did if they guessed over or under — note there’s no else block to handle if they guessed correctly. What happens if they do guess correctly? We end up passing through all the ifs without printing anything but once we return to the condition check for the while loop, we find that the condition is now false. We break out of the loop and print the congratulations statement.
This is a more complicated example of while loops, bringing conditionals into the mix too, but if you’re comfortable with this you’re good to go!

## Breaking
Say you’re trying to do some form of input verification. You want your user to input a specific string, and you want them to keep trying until they do. This is one way you might do it:

```python
n = input("Please enter 'hello':")
while n != 'hello':
  n = input("Please enter 'hello':")
```

This is pretty wordy, though. We have the same input request typed out twice, and it’s generally good form to try to minimize repetition. One way we can fix this is with a break statement:

```python
while True:
  n = input("Please enter 'hello':")
  if n == 'hello':
    break
```

A break statement does just what it sounds like it does - it breaks out of the loop. In the second example, we’ve contained everything in the while loop. Notice that we start out with a condition that will never evaluate to false: this seems problematic, but we won’t end up with an infinite loop because we have the option of breaking out of it in the body of the loop. We collect user input, compare it against our reference string, and break out of the loop if they’ve typed what we want, and move on. This is a really good way to handle ``while`` loops.

# Functions
You’ll notice that we’ve been using the word "function" to describe some of the things we’re using - like input, range, and more. So what is a function? A function is a block of organized and reusable code that performs a single task. It’s good form to minimize repetitive code, so if you find that you’re having to do the same thing a lot, that’s probably a sign that you need to write a function for it. Python has some functions built in — like input and range — but you can write your own!

Here’s a really simple function so you understand the syntax:

```python
def print_string(string):
  print(string)
  print_string("sandwich")
```
Output:
```
<output>
```

On the first line, we use ``def`` to tell Python that we’re defining a function. print_string is our function’s name, and in the parentheses are the parameters that it’ll use to generate some output. This is a really basic function, so it just prints out whatever parameter we pass it. But we could have any number of parameters of any type, and do all sorts of interesting things with them in the body of our function, which — surprise, surprise — is indented under the function definition. Under the function definition is a function call, where we use our function with the parameter set to "sandwich".

Here’s another example where instead of just printing, we do something more interesting: we return a value.

```python
def add_numbers(a,b):
  return a + b
add_numbers(3,5)
```
Output:
```
<output>
```

Notice first that we’re using multiple parameters in this new function. The next big difference is the use of return. return outputs a value that we can use in more expressions. For example, let’s try:

```python
"Hello, " + print_string("Bob")
```

This wouldn’t work, because technically print_string doesn’t return anything. It just prints a value and returns nothing, or more technically, None — an object Python uses to represent nothingness. You don’t always need to return something, but if you want to use your function output, then you do need return. For example, we could do this:

```python
add_numbers(1,3) + 5
```

Since ``add_numbers`` returns its output, we can incorporate it into other expressions without ending up with errors.

Another important distinction to be aware of when writing your own functions is the difference between global and local variables:

```python
start = 1
def add_list(numlist):
  total = 0
  for i in numlist:
    total += i
  return total

print(start)
print(total)
```
Output:
```
<output>
```

The second ``print`` statement gives an error because total is a **local variable**, not a **global variable**. ``total`` only exists inside the function definition and is not accessible outside it. On the other hand, ``start`` exists outside the function and is a global variable, accessible anywhere.

The functions you write can take all sorts of arguments and do all sorts of things, so no matter what kind of project you’re working on, you’ll probably need to write at least a couple of functions. It might take a little bit of getting used to, but once you start, you’ll never know how you managed without them!

# Classes
You might have heard of something called Object-Oriented Programming. It’s just a fancy name for a very simple concept. Take a look at everything around you. The keyboard you’re using. The book sitting next to your desk. The table you’re working on. They’re all objects — things that have properties, e.g. the keyboard’s format, the book’s title, the table’s height, and actions, e.g. , associated with them.


<table>
<tr>
  <th>
    Object
  </th>
  <th>
    Properties
  </th>
  <th>
    Actions
  </th>
</tr>

<tr>
  <td>
    Book
  </td>
  <td>
    Title <br>
    Author <br>
    Cover Image <br>
  </td>
  <td>
    Flip page <br>
    Open book <br>
    Close book <br>
  </td>
</tr>

<tr>
  <td>
    Table
  </td>
  <td>
    Height <br>
    Width <br>
    Depth <br>
    Material <br>
  </td>
  <td>
    Change Height (if it's an <a href="https://updesk.com/">Updesk</a>)
  </td>
</tr>

<tr>
  <td>
    Keyboard
  </td>
  <td>
    Keyboard format <br>
    Language <br>
    Caps Lock Enabled? <br>
    Number Pad Attached?
  </td>
  <td>
    Toggle Caps Lock
  </td>
</tr>
</table>

That’s all an object really is in programming — something with properties and actions. Why might this be useful? Well, let’s consider that we’re programming a gradebook application for a school system. What are some objects that a gradebook consists of? It would probably include the students, aggregated together into courses, of which a teacher may teach several.

What might some of the properties and actions of each of these objects be?

<table>
<tr>
  <th>Object</th>
  <th>Properties</th>
  <th>Actions</th>
</tr>

<tr>
  <td>Student</td>
  <td>
    First Name <br>
    Middle Initial <br>
    Last Name <br>
    Enrolled courses
  </td>
  <td>
    Enroll in course <br>
    Drop course <br>
    Print transcript
  </td>
</tr>

<tr>
  <td>Course</td>
  <td>
    List of Enrolled Students <br>
    List of Assignments
  </td>
  <td>
    Enroll student <br>
    Drop student <br>
    Add grade <br>
    Remove grade <br>
    Edit grade <br>
    Print grade report
  </td>
</tr>

<tr>
  <td>Teacher</td>
  <td>
    First Name <br>
    Middle Initial <br>
    Last Name <br>
    Department <br>
    Title <br>
    Position (e.g. Department Head) <br>
    List of Courses Teaching
  </td>
  <td>
    Change department <br>
    Change position <br>
    Add course taught <br>
    Remove course taught
  </td>
</tr>
</table>

Having written down the properties and actions we associate with each object, we can begin writings classes for each object. What’s a class? It’s simply a blueprint for what properties and actions an object should have. In other words, I have a class that defines a generic object, like Student. When I want specific students, such as George or Michael, I create an instance of Student, with each student’s name property set appropriately. The code might help clarify things a bit.

```python
class Student:
  def __init__(self, first, mi, last):
    self.first_name = first
    self.middle_initial = mi
    self.last_name = last
    self.enrolled_courses = []

  def enroll(self, course):
    self.enrolled_courses.append(course)
    course.enrolled_students.append(self)

  def drop(self, course):
    self.enrolled_courses.remove(course)
    course.enrolled_students.remove(self)

  def get_transcript(self):
    print(self.first_name + " " + self.middle_initial + ". " + self.last_name + ":")
    for course in self.enrolled_courses:
      print("\t" + course.course_name + ": " + str(course.get_overall_grade_for(self)))


class Course:
  def __init__(self, name):
    self.course_name = name
    self.enrolled_students = []
    self.assignments = {}

  def add_assignment(self, assignment):
    self.assignments[assignment] = {}

  def remove_assignment(self, assignment):
    del self.assignments[assignment]

  def set_grade(self, assignment, student, grade):
    self.assignments[assignment][student] = grade

  def get_overall_grade_for(self, student):
    sum_scores = 0
    num_graded = 0
    for assignment, grades in self.assignments.items():
      if student in grades.keys():
        sum_scores += grades[student]
        num_graded += 1

    if num_graded == 0:
      return "N/A"

    return sum_scores / float(num_graded)


john = Student("John", "A", "Smith")
katie = Student("Katie", "M", "Zhu")

biology = Course("Biology")
calculus = Course("Calculus")
physics = Course("Physics")

john.enroll(biology)
john.enroll(calculus)

katie.enroll(biology)
katie.enroll(calculus)
katie.enroll(physics)

biology.add_assignment("Bio exam #1")
biology.add_assignment("Bio exam #2")
physics.add_assignment("Physics homework #1")
calculus.add_assignment("Calc homework #1")
calculus.add_assignment("Calc quiz #1")

biology.set_grade("Bio exam #1", john, 90)
biology.set_grade("Bio exam #1", katie, 95)

physics.set_grade("Physics homework #1", katie, 86)

calculus.set_grade("Calc homework #1", john, 100)
calculus.set_grade("Calc homework #1", katie, 98)
calculus.set_grade("Calc quiz #1", john, 78)
calculus.set_grade("Calc quiz #1", katie, 84)

john.get_transcript()
katie.get_transcript()
```

# Conclusion
This is by no means a very extensive tutorial but we hope that you will feel more confident about pursuing coding projects now.

Below are some other handy resources for you to learn more about Python!
* [https://python101.pythonlibrary.org/intro.html](https://python101.pythonlibrary.org/intro.html)
* [https://www.codecademy.com/learn/learn-python](https://www.codecademy.com/learn/learn-python)
